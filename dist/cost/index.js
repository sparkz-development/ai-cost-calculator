"use strict";
/**
 *
 * DO NOT EDIT THIS FILE UNLESS IT IS IN /costs/src/index.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.COST_MULTIPLE = void 0;
exports.costOf = costOf;
exports.costOfPrompt = costOfPrompt;
exports.clickhousePriceCalcNonAggregated = clickhousePriceCalcNonAggregated;
exports.clickhousePriceCalc = clickhousePriceCalc;
const mappings_1 = require("./providers/mappings");
function costOf({ model, provider, }) {
    const modelLower = model === null || model === void 0 ? void 0 : model.toLowerCase();
    if (!modelLower) {
        return null;
    }
    const providerCost = mappings_1.providers.find((p) => {
        return (p.provider === provider ||
            (p.pattern && p.pattern.test(provider) ? true : false));
    });
    if (!providerCost || !providerCost.costs) {
        return null;
    }
    // We need to concat allCosts because we need to check the provider costs first and if it is not founder then fall back to make the best guess.
    // This is because we did not backfill the provider on supabase yet, and we do not plan to
    // This is really for legacy
    // TODO: after 07/2024 we can probably remove this
    const costs = providerCost.costs.concat(mappings_1.allCosts);
    const cost = costs.find((cost) => {
        const valueLower = cost.model.value.toLowerCase();
        if (cost.model.operator === "equals") {
            return valueLower === modelLower;
        }
        else if (cost.model.operator === "startsWith") {
            return modelLower.startsWith(valueLower);
        }
        else if (cost.model.operator === "includes") {
            return modelLower.includes(valueLower);
        }
    });
    return cost === null || cost === void 0 ? void 0 : cost.cost;
}
function costOfPrompt({ provider, model, promptTokens, promptCacheWriteTokens, promptCacheReadTokens, completionTokens, images = 1, perCall = 1, }) {
    var _a, _b;
    const cost = costOf({ model, provider });
    if (!cost) {
        return null;
    }
    let totalCost = 0;
    // Add cost for regular prompt tokens (these are the fresh, uncached tokens)
    totalCost += promptTokens * cost.prompt_token;
    // Add cost for cache write tokens if applicable
    if (cost.prompt_cache_write_token && promptCacheWriteTokens > 0) {
        totalCost += promptCacheWriteTokens * cost.prompt_cache_write_token;
    }
    else if (promptCacheWriteTokens > 0) {
        totalCost += promptCacheWriteTokens * cost.prompt_token;
    }
    // Add cost for cache read tokens if applicable
    if (cost.prompt_cache_read_token && promptCacheReadTokens > 0) {
        totalCost += promptCacheReadTokens * cost.prompt_cache_read_token;
    }
    else if (promptCacheReadTokens > 0) {
        totalCost += promptCacheReadTokens * cost.prompt_token;
    }
    // Add cost for completion tokens
    totalCost += completionTokens * cost.completion_token;
    // Add cost for images and per-call fees
    const imageCost = images * ((_a = cost.per_image) !== null && _a !== void 0 ? _a : 0);
    const perCallCost = perCall * ((_b = cost.per_call) !== null && _b !== void 0 ? _b : 0);
    totalCost += imageCost + perCallCost;
    return totalCost;
}
function caseForCost(costs, table, multiple) {
    return `
  CASE
  ${costs
        .map((cost) => {
        var _a, _b;
        const costPerMultiple = {
            prompt: Math.round(cost.cost.prompt_token * multiple),
            completion: Math.round(cost.cost.completion_token * multiple),
            image: Math.round(((_a = cost.cost.per_image) !== null && _a !== void 0 ? _a : 0) * multiple),
            per_call: Math.round(((_b = cost.cost.per_call) !== null && _b !== void 0 ? _b : 0) * multiple),
        };
        const costs = [];
        if (costPerMultiple.prompt > 0) {
            costs.push(`${costPerMultiple.prompt} * ${table}.prompt_tokens`);
        }
        if (costPerMultiple.completion > 0) {
            costs.push(`${costPerMultiple.completion} * ${table}.completion_tokens`);
        }
        if (costPerMultiple.image > 0) {
            costs.push(`${costPerMultiple.image}`);
        }
        if (costPerMultiple.per_call > 0) {
            costs.push(`${costPerMultiple.per_call}`);
        }
        if (costs.length > 0) {
            const costString = costs.join(" + ");
            if (cost.model.operator === "equals") {
                return `WHEN (${table}.model ILIKE '${cost.model.value}') THEN ${costString}`;
            }
            else if (cost.model.operator === "startsWith") {
                return `WHEN (${table}.model LIKE '${cost.model.value}%') THEN ${costString}`;
            }
            else if (cost.model.operator === "includes") {
                return `WHEN (${table}.model ILIKE '%${cost.model.value}%') THEN ${costString}`;
            }
            else {
                throw new Error("Unknown operator");
            }
        }
        else {
            return ``;
        }
    })
        .join("\n")}
  ELSE 0
END
`;
}
exports.COST_MULTIPLE = 1000000000;
function clickhousePriceCalcNonAggregated(table) {
    // This is so that we don't need to do any floating point math in the database
    // and we can just divide by 1_000_000 to get the cost in dollars
    const providersWithCosts = mappings_1.providers.filter((p) => p.costs && mappings_1.defaultProvider.provider !== p.provider);
    if (!mappings_1.defaultProvider.costs) {
        throw new Error("Default provider does not have costs");
    }
    return `
(
  CASE
    ${providersWithCosts
        .map((provider) => {
        if (!provider.costs) {
            throw new Error("Provider does not have costs");
        }
        return `    WHEN (${table}.provider = '${provider.provider}') 
      THEN (${caseForCost(provider.costs, table, exports.COST_MULTIPLE)})`;
    })
        .join("\n")}
    ELSE (${caseForCost(mappings_1.defaultProvider.costs, table, exports.COST_MULTIPLE)})
  END
) / ${exports.COST_MULTIPLE}
`;
}
function clickhousePriceCalc(table) {
    // This is so that we don't need to do any floating point math in the database
    // and we can just divide by 1_000_000 to get the cost in dollars
    const providersWithCosts = mappings_1.providers.filter((p) => p.costs && mappings_1.defaultProvider.provider !== p.provider);
    if (!mappings_1.defaultProvider.costs) {
        throw new Error("Default provider does not have costs");
    }
    return `
sum(
  CASE
  ${providersWithCosts
        .map((provider) => {
        if (!provider.costs) {
            throw new Error("Provider does not have costs");
        }
        return `WHEN (${table}.provider = '${provider.provider}') THEN (${caseForCost(provider.costs, table, exports.COST_MULTIPLE)})`;
    })
        .join("\n")}
    ELSE ${caseForCost(mappings_1.defaultProvider.costs, table, exports.COST_MULTIPLE)}
  END
  ) / ${exports.COST_MULTIPLE}
`;
}
